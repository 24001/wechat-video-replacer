# 微信视频替换工具 - 产品需求文档（最终版）

> **开发状态**：✅ 权限突破完成 | 🚧 核心功能开发中
> 
> **最后更新**：2025-01-10 23:30

---

## ✅ 已完成的部分

### 容器访问权限（已验证可用）

**实现方式**：
- ✅ 使用 ldid 签名嵌入 entitlements
- ✅ 通过 TrollStore 安装
- ✅ 直接访问容器（无需 RootHelper）
- ✅ 完整的 entitlements 配置（15个权限）

**验证结果**：
```
✅ 成功读取 208 个容器
✅ 找到微信容器：com.tencent.xin
   路径：/var/mobile/Containers/Data/Application/91FC0093-DD75-4AA3-BC68-27956F0DD056
✅ 可访问 Documents 和 Library 目录
✅ 可读写 tmp 目录
```

**关键技术点**：
- 使用 `com.apple.private.security.container-manager` 权限
- 使用 `com.apple.private.MobileContainerManager.allowed` 权限  
- 使用 `com.apple.security.exception.files.absolute-path.read-write` 权限
- 移除被禁止的 entitlements（避免闪退）

---

## 🚧 进行中的部分

- 视频选择和导出功能（基础代码已完成）
- 文件替换逻辑（待实现）
- UI 重构（待实现）
- 完整流程集成（待实现）

---

## 一、项目概述

### 1.1 项目名称
微信视频素材替换工具 (WeChat Video Replacer)

### 1.2 项目目标
开发一个iPad原生应用，通过TrollStore签名安装，实现将用户自定义视频素材替换为微信缓存视频的功能，让微信识别并使用用户的自定义素材。

### 1.3 使用场景
- 微信视频号发布时使用自定义素材
- 替换微信草稿箱中的视频内容
- 在微信中使用预先制作好的视频素材
- 同一素材多次发布到微信
- 多个素材轮换发布

### 1.4 目标平台
- 设备: iPad
- 安装方式: TrollStore
- iOS版本: 支持TrollStore的iOS版本 (14.0-16.6.1)

---

## 二、核心功能需求

### 2.1 功能流程图

```
用户首次使用:
────────────────
1. 打开应用
2. 选择素材视频 (从相册/文件)
3. 点击"一键替换"
4. 应用自动完成所有操作
5. 去微信发布视频 ✓

用户再次使用 (同一素材):
────────────────
1. 打开应用
2. 直接点击"一键替换"
3. 应用自动完成所有操作
4. 去微信发布视频 ✓

用户更换素材:
────────────────
1. 打开应用
2. 点击"更换素材" → 选择新素材
3. 点击"一键替换"
4. 应用自动完成所有操作
5. 去微信发布视频 ✓
```

### 2.2 详细功能说明

#### 功能1: 视频素材选择与记忆

**用户操作:**
- 首次使用: 点击"选择素材"按钮
- 更换素材: 点击"更换素材"按钮
- 从以下来源选择视频:
  - iPad相册 (Photos) - 推荐
  - 文件系统 (Files)

**应用行为:**
- 记住用户选择的素材信息:
  - PHAsset标识符 (相册资源唯一ID)
  - 文件名
  - 文件大小
  - 视频时长
- 将素材信息持久化保存 (UserDefaults)
- 下次打开应��自动加载上次选择的素材

**显示信息:**
- 当前使用的素材文件名
- 文件大小
- 视频时长

#### 功能2: 一键替换 (核心功能)

**触发条件:**
- 用户点击"一键替换"按钮

**应用自动执行完整流程:**

##### 步骤1: 验证素材
```
检查是否已选择素材:
- 未选择 → 提示"请先选择素材"并终止
- 已选择 → 继续执行
```

##### 步骤2: 从相册导出素材
```
功能: 从iPad相册导出视频文件
输入: PHAsset标识符 (记住的素材ID)
输出: 临时文件路径

详细逻辑:
1. 通过PHAsset ID获取相册中的视频资源
2. 使用PHImageManager导出视频到应用临时目录
3. 保持原始文件名 (重要!)
   - 例如: IMG_1234.MOV、my_video.mp4等
4. 获取导出文件的完整路径
```

##### 步骤3: 定位微信容器
```
功能: 自动查找微信应用的数据容器目录
方法: 通过Bundle ID "com.tencent.xin" 精准定位

详细逻辑:
1. 遍历 /var/mobile/Containers/Data/Application/
2. 读取每个容器的 .com.apple.mobile_container_manager.metadata.plist
3. 查找 MCMMetadataIdentifier 为 "com.tencent.xin" 的容器
4. 返回完整路径: /var/mobile/Containers/Data/Application/[UUID]/

错误处理:
- 未找到 → 提示"未安装微信或无法访问"
```

##### 步骤4: 上传素材到微信tmp目录
```
功能: 将素材复制到微信tmp目录
源路径: /app临时目录/IMG_1234.MOV
目标路径: /微信容器/tmp/IMG_1234.MOV

关键点:
✓ 必须保持原文件名 (用于后续识别!)
✓ 使用文件复制 (非移动)
✓ 验证复制是否成功

文件名识别的重要性:
- 上传后的文件名: IMG_1234.MOV
- 我们需要记住这个名称
- 后续替换操作需要通过这个名称定位我们的文件
```

##### 步骤5: 查找微信最新缓存视频
```
功能: 在微信tmp目录查找最新的LocalShortVideo文件
扫描目录: /微信容器/tmp/

详细逻辑:
1. 列出tmp目录所有文件
2. 筛选以 "LocalShortVideo" 开头的文件
3. 读取每个文件的创建时间 (creationDate)
4. 按创建时间降序排序
5. 返回最新的文件名
   - 例如: LocalShortVideo_1736412345678.mp4

错误处理:
- 未找到 → 提示"未找到微信视频缓存，请先在微信中录制视频"
```

##### 步骤6: 执行文件替换操作
```
功能: 将我们的素材伪装成微信缓存视频

输入:
- ourFileName: IMG_1234.MOV (我们上传的素材)
- cacheFileName: LocalShortVideo_1736412345678.mp4 (微信缓存)
- tmpPath: /微信容器/tmp/

执行步骤:

a. 备份微信原始缓存
   源文件: /微信/tmp/LocalShortVideo_1736412345678.mp4
   目标文件: /微信/tmp/backup_1736412345678.tmp
   操作: 重命名/移动

b. 重命名我们的素材为微信缓存的名称
   源文件: /微信/tmp/IMG_1234.MOV
   目标文件: /微信/tmp/LocalShortVideo_1736412345678.mp4
   操作: 重命名/移动

结果:
✓ 微信会把我们的素材当成它自己的缓存
✓ 用户在微信中发布视频时，实际发布的是我们的素材
```

##### 步骤7: 完成反馈
```
成功:
- 显示"替换成功！可以去微信发布了"
- 记录操作历史 (可选)

失败:
- 显示具体错误信息
- 提供重试选项
- 自动回滚操作 (如果部分完成)
```

### 2.3 素材记忆与重复使用机制

#### 核心原理
```
选择素材后的行为:
1. 用户选择素材A → 应用保存素材A的PHAsset ID
2. 每次点击"一键替换" → 重新从相册读取素材A
3. 每次都执行完整的复制→上传→替换流程

为什么每次都要重新复制?
- 微信发布视频后会删除/移动tmp目录中的文件
- 我们的素材已经被重命名为LocalShortVideo
- tmp目录变空或有新的缓存文件
- 因此下次需要重新上传素材
```

#### 数据持久化
```swift
// 保存的素材信息结构
struct SavedVideoInfo {
    let assetIdentifier: String  // PHAsset的localIdentifier
    let fileName: String          // 原始文件名
    let fileSize: Int64          // 文件大小(字节)
    let duration: Double         // 视频时长(秒)
    let savedDate: Date          // 保存时间
}

// 存储方式: UserDefaults
// 键: "savedVideoInfo"
```

#### 素材更换流程
```
场景: 用户正在使用素材A，现在想换成素材B

操作流程:
1. 用户点击"更换素材"按钮
2. 打开相册/文件选择器
3. 用户选择新素材B
4. 应用保存新素材B的信息 (覆盖素材A的信息)
5. 界面更新显示素材B的信息
6. 下次点击"一键替换"将使用素材B

技术实现:
- 删除旧的SavedVideoInfo
- 创建新的SavedVideoInfo
- 保存到UserDefaults
- 刷新UI显示
```

---

## 三、用户界面设计

### 3.1 主界面布局 (最终版)

```
┌─────────────────────────────────────┐
│       微信视频素材替换工具           │
├─────────────────────────────────────┤
│                                     │
│  📹 当前使用的素材:                 │
│  ┌─────────────────────────────┐   │
│  │ ✓ IMG_1234.MOV              │   │
│  │ 15.2 MB | 00:30             │   │
│  │ 上次使用: 2025-01-09 14:30  │   │
│  └─────────────────────────────┘   │
│                                     │
│     [🔄 更换素材]                   │
│                                     │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  │
│                                     │
│     [ 🚀 一键替换 ]                 │
│     (自动完成所有操作)               │
│                                     │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  │
│                                     │
│  执行步骤: (自动显示进度)            │
│  ✓ 从相册导出素材                   │
│  ✓ 定位微信容器                     │
│  ✓ 上传到微信tmp目录                │
│  ✓ 查找最新视频缓存                 │
│  ✓ 执行文件替换                     │
│  ✓ 完成                            │
│                                     │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  │
│                                     │
│  状态: 替换成功！可以去微信发布了    │
│                                     │
│  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━  │
│                                     │
│  💡 使用说明:                       │
│  • 首次使用需选择素材               │
│  • 点击"一键替换"自动完成所有操作   │
│  • 可重复使用同一素材多次发布       │
│  • 需要换素材时点"更换素材"         │
│                                     │
└─────────────────────────────────────┘
```

### 3.2 交互设计

#### 按钮状态
| 按钮 | 初始状�� | 选择素材后 | 替换执行中 |
|------|---------|-----------|-----------|
| 选择素材/更换素材 | 可用 | 可用 | 禁用 |
| 一键替换 | 禁用 | 可用 | 禁用 |

#### 状态提示
```
等待状态:
- "请先选择素材"
- "就绪，点击一键替换开始"

执行中状态:
- "正在从相册导出..." (带进度条)
- "正在定位微信容器..."
- "正在上传素材..."
- "正在查找缓存..."
- "正在替换文件..."

完成状态:
- "替换成功！可以去微信发布了" ✓
- "错误: [具体错误信息]" ✗
```

#### 错误处理
| 错误场景 | 错误提示 | 建议操作 |
|---------|---------|---------|
| 未选择素材 | "请先选择素材" | 点击选择素材 |
| 未找到微信 | "未安装微信或无法访问微信数据" | 安装微信/检查权限 |
| 权限不足 | "权限不足，请通过TrollStore安装" | 重新安装 |
| 未找到缓存 | "未找到微信视频缓存，请先在微信中录制视频" | 去微信录制 |
| 文件操作失败 | "文件操作失败: [具体错误]" | 提供重试按钮 |
| 相册访问失败 | "无法访问相册，请检查权限" | 去设置开启 |

---

## 四、技术需求

### 4.1 开发环境
- 开发语言: Swift (推荐) / Objective-C
- IDE: Xcode 14.0+
- 最低部署目标: iOS 14.0
- 架构: arm64
- UI框架: UIKit / SwiftUI

### 4.2 权限配置

#### Info.plist
```xml
<!-- 相册访问权限 -->
<key>NSPhotoLibraryUsageDescription</key>
<string>需要访问相册以选择要上传的视频素材</string>
```

#### entitlements.plist (关键配置 - 已验证可用)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <!-- 突破沙盒限制 - 核心权限 -->
    <key>com.apple.private.security.container-required</key>
    <false/>

    <!-- 平台级应用权限 - 系统应用级别 -->
    <key>platform-application</key>
    <true/>

    <!-- 绝对路径读写根目录 - Filza 关键权限！-->
    <key>com.apple.security.exception.files.absolute-path.read-write</key>
    <array>
        <string>/</string>
    </array>

    <!-- 访问所有文件 - 文件系统完全访问 -->
    <key>com.apple.security.files.all</key>
    <true/>

    <!-- 无容器限制 - 跨容器访问 -->
    <key>com.apple.private.security.no-container</key>
    <true/>

    <!-- 访问应用数据容器 - 核心权限 -->
    <key>com.apple.private.security.storage.AppDataContainers</key>
    <true/>

    <!-- 容器管理器权限 - 访问所有应用容器的核心权限！-->
    <key>com.apple.private.security.container-manager</key>
    <true/>

    <!-- Mobile Container Manager - Filza 使用的关键权限！-->
    <key>com.apple.private.MobileContainerManager.allowed</key>
    <true/>

    <!-- 用户选择的文件只读 -->
    <key>com.apple.security.files.user-selected.read-only</key>
    <true/>

    <!-- 用户选择的文件读写 -->
    <key>com.apple.security.files.user-selected.read-write</key>
    <true/>

    <!-- 根文件系统只读 -->
    <key>com.apple.security.files.root.read-only</key>
    <true/>

    <!-- 根文件系统读写 -->
    <key>com.apple.security.files.root.read-write</key>
    <true/>

    <!-- 访问所有应用组容器 -->
    <key>com.apple.security.application-groups</key>
    <array>
        <string>*</string>
    </array>

    <!-- 任务端口访问 -->
    <key>task_for_pid-allow</key>
    <true/>

    <!-- 获取任务允许 -->
    <key>get-task-allow</key>
    <true/>

    <!-- 禁用沙盒 - 文件系统完全访问 -->
    <key>com.apple.private.security.no-sandbox</key>
    <true/>

    <!-- Persona 管理权限 -->
    <key>com.apple.private.persona-mgmt</key>
    <true/>
</dict>
</plist>
```

**⚠️ 重要说明 - 被禁止的 entitlements：**

以下 entitlements 在 iOS 15+ A12+ 设备上被禁止，会导致应用闪退，**不要使用**：
- ❌ `com.apple.private.cs.debugger`
- ❌ `com.apple.private.skip-library-validation`
- ❌ `dynamic-codesigning`

### 4.3 签名方式（关键！）

**使用 ldid 签名（Filza 方式）：**

```bash
# 使用 ldid 对主应用签名并嵌入 entitlements
ldid -Sentitlements.plist WechatVideoReplacer.app/WechatVideoReplacer
```

**为什么需要 ldid 签名？**
1. TrollStore 需要读取已嵌入的 entitlements
2. 不能预先用 Apple 证书签名（会冲突）
3. ldid 签名可以嵌入 entitlements 且 TrollStore 接受
4. Filza 就是用这种方式

**编译配置：**
```
Xcode Build Settings:
- Code Signing Identity: ""
- CODE_SIGNING_REQUIRED: NO
- CODE_SIGNING_ALLOWED: NO

然后用 ldid 手动签名
```

### 4.4 核心技术实现

#### 4.4.1 定位微信容器（直接访问方式）
```swift
/**
 * 功能描述: 通过Bundle ID定位微信应用的数据容器
 * 说明: 使用 container-manager entitlement 直接访问，不需要 root 权限
 * Returns:
 *     String?: 微信容器完整路径，未找到则返回nil
 */
func findWechatContainer() -> String? {
    let containersPath = "/var/mobile/Containers/Data/Application/"
    let fm = FileManager.default

    guard let containers = try? fm.contentsOfDirectory(atPath: containersPath) else {
        return nil
    }

    for uuid in containers {
        let metadataPath = "\(containersPath)/\(uuid)/.com.apple.mobile_container_manager.metadata.plist"

        if let metadata = NSDictionary(contentsOfFile: metadataPath),
           let bundleID = metadata["MCMMetadataIdentifier"] as? String,
           bundleID == "com.tencent.xin" {
            return "\(containersPath)/\(uuid)"
        }
    }
    return nil
}
```

#### 4.3.2 从相册导出视频
```swift
import Photos

/**
 * 功能描述: 从相册导出视频到临时目录
 * Args:
 *     assetID (String): PHAsset的localIdentifier
 * Returns:
 *     (path: String, fileName: String)?: 导出文件路径和文件名
 */
func exportVideoFromPhotos(assetID: String) -> (path: String, fileName: String)? {
    let fetchResult = PHAsset.fetchAssets(
        withLocalIdentifiers: [assetID],
        options: nil
    )

    guard let asset = fetchResult.firstObject else {
        return nil
    }

    let options = PHVideoRequestOptions()
    options.version = .current
    options.deliveryMode = .highQualityFormat

    let semaphore = DispatchSemaphore(value: 0)
    var resultPath: String?
    var resultFileName: String?

    PHImageManager.default().requestAVAsset(forVideo: asset, options: options) { avAsset, _, _ in
        guard let urlAsset = avAsset as? AVURLAsset else {
            semaphore.signal()
            return
        }

        let sourceURL = urlAsset.url
        let fileName = sourceURL.lastPathComponent
        let tempPath = NSTemporaryDirectory() + fileName

        do {
            // 如果已存在则删除
            if FileManager.default.fileExists(atPath: tempPath) {
                try FileManager.default.removeItem(atPath: tempPath)
            }

            // 复制到临时目录 (保持原文件名!)
            try FileManager.default.copyItem(atPath: sourceURL.path, toPath: tempPath)

            resultPath = tempPath
            resultFileName = fileName
        } catch {
            print("导出失败: \(error)")
        }

        semaphore.signal()
    }

    semaphore.wait()

    if let path = resultPath, let name = resultFileName {
        return (path, name)
    }
    return nil
}
```

#### 4.3.3 查找最新缓存视频
```swift
/**
 * 功能描述: 在微信tmp目录中查找最新的LocalShortVideo文件
 * Args:
 *     tmpPath (String): 微信tmp目录路径
 * Returns:
 *     String?: 最新视频文件名，未找到则返回nil
 */
func findLatestVideoCache(in tmpPath: String) -> String? {
    let fm = FileManager.default

    guard let files = try? fm.contentsOfDirectory(atPath: tmpPath) else {
        return nil
    }

    // 筛选LocalShortVideo开头的文件
    let videoFiles = files.filter { $0.hasPrefix("LocalShortVideo") }

    guard !videoFiles.isEmpty else {
        return nil
    }

    // 按创建时间降序排序
    let sortedFiles = videoFiles.sorted { file1, file2 in
        let path1 = "\(tmpPath)/\(file1)"
        let path2 = "\(tmpPath)/\(file2)"

        let attr1 = try? fm.attributesOfItem(atPath: path1)
        let attr2 = try? fm.attributesOfItem(atPath: path2)

        let date1 = attr1?[.creationDate] as? Date ?? Date.distantPast
        let date2 = attr2?[.creationDate] as? Date ?? Date.distantPast

        return date1 > date2  // 最新的在前
    }

    return sortedFiles.first
}
```

#### 4.3.4 执行文件替换
```swift
/**
 * 功能描述: 执行视频文件替换操作
 * Args:
 *     ourFileName (String): 我们上传的视频文件名 (如: IMG_1234.MOV)
 *     cacheFileName (String): 微信缓存视频文件名 (如: LocalShortVideo_xxx.mp4)
 *     tmpPath (String): 微信tmp目录路径
 * Returns:
 *     Bool: 替换是否成功
 */
func replaceVideo(ourFileName: String, cacheFileName: String, in tmpPath: String) -> Bool {
    let fm = FileManager.default

    let ourFilePath = "\(tmpPath)/\(ourFileName)"
    let cacheFilePath = "\(tmpPath)/\(cacheFileName)"
    let backupPath = "\(tmpPath)/backup_\(Date().timeIntervalSince1970).tmp"

    do {
        // 1. 验证我们的文件存在
        guard fm.fileExists(atPath: ourFilePath) else {
            print("错误: 找不到上传的文件 \(ourFileName)")
            return false
        }

        // 2. 验证微信缓存文件存在
        guard fm.fileExists(atPath: cacheFilePath) else {
            print("错误: 找不到微信缓存文件 \(cacheFileName)")
            return false
        }

        // 3. 备份微信原始缓存
        try fm.moveItem(atPath: cacheFilePath, toPath: backupPath)
        print("✓ 已备份: \(cacheFileName) → backup")

        // 4. 重命名我们的素材为微信缓存的名称
        try fm.moveItem(atPath: ourFilePath, toPath: cacheFilePath)
        print("✓ 已替换: \(ourFileName) → \(cacheFileName)")

        return true
    } catch {
        print("替换失败: \(error)")

        // 尝试回滚
        if fm.fileExists(atPath: backupPath) && !fm.fileExists(atPath: cacheFilePath) {
            try? fm.moveItem(atPath: backupPath, toPath: cacheFilePath)
            print("已回滚操作")
        }

        return false
    }
}
```

#### 4.3.5 一键替换完整流程
```swift
/**
 * 功能描述: 一键替换完整实现
 */
func oneClickReplace() {
    // 1. 检查是否已选择素材
    guard let savedVideo = loadSavedVideo() else {
        showAlert("请先选择素材")
        return
    }

    updateStatus("正在从相册导出素材...")

    // 2. 从相册导出视频
    guard let (tempPath, fileName) = exportVideoFromPhotos(assetID: savedVideo.assetIdentifier) else {
        showAlert("从相册导出素材失败")
        return
    }

    updateStatus("正在定位微信容器...")

    // 3. 定位微信容器
    guard let wechatContainer = findWechatContainer() else {
        showAlert("未找到微信应用或无法访问")
        return
    }

    let wechatTmpPath = "\(wechatContainer)/tmp"

    updateStatus("正在上传素材到微信...")

    // 4. 上传素材到微信tmp (保持原文件名!)
    let targetPath = "\(wechatTmpPath)/\(fileName)"
    do {
        // 如果已存在则删除
        if FileManager.default.fileExists(atPath: targetPath) {
            try FileManager.default.removeItem(atPath: targetPath)
        }

        try FileManager.default.copyItem(atPath: tempPath, toPath: targetPath)
        print("✓ 已上传: \(fileName) → 微信tmp")
    } catch {
        showAlert("上传素材失败: \(error.localizedDescription)")
        return
    }

    updateStatus("正在查找最新视频缓存...")

    // 5. 查找微信最新缓存
    guard let latestCache = findLatestVideoCache(in: wechatTmpPath) else {
        showAlert("未找到微信视频缓存，请先在微信中录制视频")
        return
    }

    updateStatus("正在执行文件替换...")

    // 6. 执行替换
    let success = replaceVideo(
        ourFileName: fileName,
        cacheFileName: latestCache,
        in: wechatTmpPath
    )

    // 7. 清理临时文件
    try? FileManager.default.removeItem(atPath: tempPath)

    // 8. 显示结果
    if success {
        updateStatus("替换成功！可以去微信发布了 ✓")
        showAlert("替换成功！", message: "现在可以去微信中发布视频了")
    } else {
        updateStatus("替换失败")
        showAlert("替换失败，请重试")
    }
}
```

### 4.4 数据持久化实现

```swift
import Foundation

/**
 * 功能描述: 素材信息数据结构
 */
struct SavedVideoInfo: Codable {
    let assetIdentifier: String  // PHAsset的localIdentifier
    let fileName: String          // 原始文件名
    let fileSize: Int64          // 文件大小(字节)
    let duration: Double         // 视频时长(秒)
    let savedDate: Date          // 保存时间
}

/**
 * 功能描述: 保存素材信息
 */
func saveVideo(info: SavedVideoInfo) {
    let encoder = JSONEncoder()
    if let data = try? encoder.encode(info) {
        UserDefaults.standard.set(data, forKey: "savedVideoInfo")
        UserDefaults.standard.synchronize()
    }
}

/**
 * 功能描述: 加载保存的素材信息
 */
func loadSavedVideo() -> SavedVideoInfo? {
    guard let data = UserDefaults.standard.data(forKey: "savedVideoInfo") else {
        return nil
    }

    let decoder = JSONDecoder()
    return try? decoder.decode(SavedVideoInfo.self, from: data)
}

/**
 * 功能描述: 清除保存的素材信息
 */
func clearSavedVideo() {
    UserDefaults.standard.removeObject(forKey: "savedVideoInfo")
    UserDefaults.standard.synchronize()
}
```

### 4.5 关键常量定义

```swift
// 微信相关常量
struct WechatConstants {
    static let bundleID = "com.tencent.xin"
    static let containerBasePath = "/var/mobile/Containers/Data/Application/"
    static let metadataFile = ".com.apple.mobile_container_manager.metadata.plist"
    static let metadataKeyBundleID = "MCMMetadataIdentifier"
    static let videoCachePrefix = "LocalShortVideo"
}

// UserDefaults键
struct StorageKeys {
    static let savedVideoInfo = "savedVideoInfo"
}

// 状态提示文本
struct StatusMessages {
    static let waitingForSelection = "请先选择素材"
    static let ready = "就绪，点击一键替换开始"
    static let exporting = "正在从相册导出素材..."
    static let locatingWechat = "正在定位微信容器..."
    static let uploading = "正在上传素材到微信..."
    static let findingCache = "正在查找最新视频缓存..."
    static let replacing = "正在执行文件替换..."
    static let success = "替换成功！可以去微信发布了 ✓"
    static let failed = "替换失败"
}
```

---

## 五、非功能性需求

### 5.1 性能要求
- 相册导出响应时间: < 3秒 (对于50MB以内视频)
- 文件上传响应时间: < 2秒
- 替换操作完成时间: < 1秒
- 整体流程完成时间: < 10秒
- 界面响应时间: < 100ms

### 5.2 稳定性要求
- 操作失败时自动回滚
- 关键操作提供事务性保证
- 异常情况下不破坏微信原有文件
- 应用崩溃不影响微信正常使用
- 文件名冲突自动处理

### 5.3 用户体验要求
- 操作步骤清晰明了，一键完成
- 错误提示友好易懂
- 提供详细的操作进度反馈
- 支持取消正在进行的操作 (可选)
- 界面简洁美观

### 5.4 安全性要求
- 仅操作微信tmp目录
- 不修改微信其他数据
- 备份原始文件防止数据丢失
- 操作前验证文件完整性
- 不收集用户隐私数据

---

## 六、测试需求

### 6.1 功能测试
- [ ] 视频选择功能 (相册、文件系统)
- [ ] 素材信息记忆功能
- [ ] 相册视频导出功能
- [ ] 微信容器定位准确性
- [ ] 文件上传功能 (保持文件名)
- [ ] 缓存视频查找功能 (按时间排序)
- [ ] 文件替换功能
- [ ] 一键替换完整流程
- [ ] 素材更换功能
- [ ] 重复使用同一素材
- [ ] 错误处理和提示

### 6.2 兼容性测试
- [ ] 不同iOS版本 (14.0-16.6.1)
- [ ] 不同iPad机型
- [ ] 不同微信版本
- [ ] TrollStore不同版本
- [ ] 不同视频格式 (MP4, MOV等)

### 6.3 压力测试
- [ ] 大文件处理 (100MB+)
- [ ] 长时间运行稳定性
- [ ] 多次重复操作
- [ ] 频繁切换素材
- [ ] 连续使用100次

### 6.4 异常场景测试
- [ ] 微信未安装
- [ ] 权限不足
- [ ] 磁盘空间不足
- [ ] tmp目录为空
- [ ] 文件正在被使用
- [ ] 相册访问被拒绝
- [ ] 素材已被删除
- [ ] 文件名冲突
- [ ] 网络异常 (如适用)

---

## 七、交付物

### 7.1 开发交付
- [ ] iOS应用源代码
- [ ] Xcode项目文件
- [ ] entitlements配置文件
- [ ] Info.plist配置
- [ ] 编译好的IPA文件
- [ ] 代码注释完整

### 7.2 文档交付
- [ ] 用户使用手册
- [ ] 技术实现文档
- [ ] API文档
- [ ] 测试报告
- [ ] 常见问题解答

### 7.3 安装说明
- [ ] TrollStore安装步骤
- [ ] 权限配置说明
- [ ] 初次使用指南
- [ ] 故障排除指南

---

## 八、项目里程碑

### Phase 1: 基础框架 (2-3天)
- [ ] 创建Xcode项目
- [ ] 配置entitlements和Info.plist
- [ ] 实现UI界面
- [ ] 实现数据持久化 (UserDefaults)

### Phase 2: 核心功能 (3-4天)
- [ ] 实现相册选择和导出
- [ ] 实现微信容器定位
- [ ] 实现文件上传 (保持文件名)
- [ ] 实现缓存查找
- [ ] 实现文件替换

### Phase 3: 集成测试 (2-3天)
- [ ] 集成完整的一键替换流程
- [ ] 实现错误处理和回滚
- [ ] 实现进度反馈
- [ ] 功能测试

### Phase 4: 优化打包 (1-2天)
- [ ] 用户体验优化
- [ ] 性能优化
- [ ] 打包IPA
- [ ] 编写文档

**总计: 8-12天**

---

## 九、风险评估

### 9.1 技术风险
| 风��项 | 影响程度 | 概率 | 应对方案 |
|--------|---------|------|---------|
| iOS系统更新导致权限失效 | 高 | 中 | 跟踪iOS更新，及时适配 |
| 微信更新改变文件结构 | 中 | 低 | 监控微信更新，预留适配时间 |
| TrollStore漏洞被修复 | 高 | 中 | 提供降级方案说明 |
| 文件名识别失败 | 中 | 低 | 增加文件验证机制 |
| 相册权限获取失败 | 低 | 低 | 清晰提示用户授权 |

### 9.2 业务风险
| 风险项 | 影响程度 | 概率 | 应对方案 |
|--------|---------|------|---------|
| 用户操作失误导致数据丢失 | 中 | 低 | 提供文件备份功能 |
| 替换后微信检测异常 | 中 | 低 | 测试多种场景，确保兼容性 |
| 素材被删除导致无法使用 | 低 | 中 | 检测素材有效性，提示重新选择 |

---

## 十、附录

### 10.1 完整使用流程示例

#### 场景1: 首次使用
```
1. 用户安装应用 (通过TrollStore)
2. 打开应用
3. 点击"选择素材"
4. 从相册选择 my_video.mp4
5. 应用显示素材信息
6. 用户点击"一键替换"
7. 应用自动执行:
   - 从相册导出 my_video.mp4
   - 定位微信容器
   - 上传到微信tmp
   - 查找LocalShortVideo_xxx.mp4
   - 执行替换
8. 显示"替换成功"
9. 用户去微信发布视频 ✓
```

#### 场景2: 重复使用同一素材
```
1. 用户第二次打开应用
2. 应用自动加载上次的素材
3. 用户直接点击"一键替换"
4. 应用自动执行完整流程
5. 显示"替换成功"
6. 用户去微信发布视频 ✓
```

#### 场景3: 更换素材
```
1. 用户正在使用 product_a.mp4
2. 现在想换成 product_b.mp4
3. 点击"更换素材"
4. 从相册选择 product_b.mp4
5. 应用更新显示新素材信息
6. 点击"一键替换"
7. 应用自动执行完整流程
8. 显示"替换成功"
9. 用户去微信发布视频 ✓
```

### 10.2 术语表
- **TrollStore**: iOS平台的免签名应用安装工具，利用CoreTrust漏洞
- **Filza**: iOS文件管理器应用，通过TrollStore安装可获得系统级权限
- **Bundle ID**: iOS应用的唯一标识符，微信为 com.tencent.xin
- **沙盒 (Sandbox)**: iOS应用的隔离环境，限制应用访问其他应用数据
- **entitlements**: iOS应用权限配置文件，定义应用的特殊权限
- **PHAsset**: Photos框架中代表相册资源的对象
- **LocalShortVideo**: 微信视频缓存文件的命名前缀

### 10.3 关键文件路径参考
```
微信容器结构:
/var/mobile/Containers/Data/Application/[UUID]/
├── .com.apple.mobile_container_manager.metadata.plist
├── Documents/
├── Library/
└── tmp/
    ├── LocalShortVideo_1736412345678.mp4  ← 微信缓存
    ├── LocalShortVideo_1736412345679.mp4
    └── IMG_1234.MOV  ← 我们上传的素材

应用临时目录:
/var/mobile/Containers/Data/Application/[我们的UUID]/tmp/
└── IMG_1234.MOV  ← 从相册导出的临时文件
```

### 10.4 参考资料
- TrollStore官方文档: https://github.com/opa334/TrollStore
- iOS文件系统结构文档
- Swift FileManager API文档
- PHPhotoLibrary使用文档
- 微信应用结构分析

### 10.5 开发建议
1. **文件名处理**: 务必保持原文件名，这是识别我们上传文件的唯一方式
2. **错误处理**: 每个文件操作都要try-catch，并提供友好提示
3. **事务性**: 替换失败时自动回滚，不破坏原有文件
4. **日志记录**: 关键步骤打印日志，便于调试
5. **UI反馈**: 每个步骤都要更新UI状态，让用户知道进度
6. **权限验证**: 启动时检查TrollStore安装和权限配置

---

**文档版本**: v2.0 (最终版)
**创建日期**: 2025-01-09
**最后更新**: 2025-01-09 18:00
**文档状态**: 已确认
**变更说明**:
- 明确了一键替换的完整逻辑
- 强调了文件名识别的重要性
- 详细说明了素材记忆和重复使用机制
- 完善了代码实现和错误处理
- 增加了完整使用流程示例
