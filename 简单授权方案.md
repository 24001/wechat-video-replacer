# 🔐 简单卡密授权方案

## 💡 核心思路

**本地卡密验证 + 加密算法** - 不需要服务器，但仍然有效

### 工作原理

1. **预设卡密算法**：使用设备信息 + 时间 + 密钥生成有效卡密
2. **本地验证**：应用内验证卡密是否正确
3. **时间限制**：卡密包含过期时间
4. **设备绑定**：卡密绑定设备标识

## 🔧 简化实现方案

### 1. 卡密生成算法（你的服务器端）

```php
<?php
// PHP 卡密生成脚本（你在 bsphp.com 上部署）

function generateCardCode($deviceId, $days = 30) {
    $secretKey = "wechat_video_replacer_2024_secret";
    $expireTime = time() + ($days * 24 * 60 * 60);
    
    // 组合数据：设备ID + 过期时间 + 密钥
    $data = $deviceId . "|" . $expireTime . "|" . $secretKey;
    
    // SHA256 哈希
    $hash = hash('sha256', $data);
    
    // 取前16位，格式化为卡密
    $cardCode = strtoupper(substr($hash, 0, 16));
    
    // 每4位插入-分隔符，增加可读性
    $formatted = substr($cardCode, 0, 4) . '-' . 
                 substr($cardCode, 4, 4) . '-' . 
                 substr($cardCode, 8, 4) . '-' . 
                 substr($cardCode, 12, 4);
    
    return [
        'card_code' => $formatted,
        'device_id' => $deviceId,
        'expire_time' => $expireTime,
        'expire_date' => date('Y-m-d H:i:s', $expireTime)
    ];
}

// API 接口
if ($_GET['action'] === 'generate') {
    $deviceId = $_GET['device_id'] ?? '';
    $days = intval($_GET['days'] ?? 30);
    
    if (empty($deviceId)) {
        echo json_encode(['error' => '设备ID不能为空']);
        exit;
    }
    
    $result = generateCardCode($deviceId, $days);
    echo json_encode($result);
}
?>
```

### 2. iOS 应用端验证

```swift
class SimpleLicenseService {
    private static let secretKey = "wechat_video_replacer_2024_secret"
    
    static func verifyCardCode(_ cardCode: String, deviceId: String) -> (valid: Bool, expireTime: TimeInterval) {
        // 移除分隔符
        let cleanCode = cardCode.replacingOccurrences(of: "-", with: "")
        
        // 尝试不同的天数（1-365天）
        let now = Date().timeIntervalSince1970
        
        for days in [1, 7, 30, 90, 365] {
            let testExpireTime = now + TimeInterval(days * 24 * 60 * 60)
            let testData = "\(deviceId)|\(Int(testExpireTime))|\(secretKey)"
            let testHash = SHA256.hash(data: testData.data(using: .utf8) ?? Data())
            let testCode = testHash.prefix(8).map { String(format: "%02X", $0) }.joined()
            
            if testCode == cleanCode && testExpireTime > now {
                return (valid: true, expireTime: testExpireTime)
            }
        }
        
        return (valid: false, expireTime: 0)
    }
}
```

## 🎯 实际使用流程

### 用户体验

1. **首次安装**：显示卡密输入界面
2. **输入卡密**：例如 `A1B2-C3D4-E5F6-G7H8`
3. **验证成功**：进入主应用，保存授权状态
4. **再次打开**：自动检查，有效期内直接进入

### 管理员操作

1. **用户提供设备ID**：应用显示设备标识
2. **生成卡密**：通过 PHP 脚本生成
3. **提供卡密**：发给用户
4. **设备绑定**：一个卡密只能在一个设备使用

## 🛡️ 安全特性

### 1. 设备绑定
```swift
private static func getDeviceID() -> String {
    let udid = UIDevice.current.identifierForVendor?.uuidString ?? "unknown"
    let model = UIDevice.current.model
    let system = UIDevice.current.systemVersion
    
    let combined = "\(udid)-\(model)-\(system)"
    let hash = SHA256.hash(data: combined.data(using: .utf8) ?? Data())
    return hash.compactMap { String(format: "%02x", $0) }.joined().prefix(8).description
}
```

### 2. 关键字符串加密
```swift
private static let encryptedSecretKey: [UInt8] = [
    119, 101, 99, 104, 97, 116, 95, 118, 105, 100, 101, 111, 95, 114, 101, 112, 108, 97, 99, 101, 114, 95, 50, 48, 50, 52, 95, 115, 101, 99, 114, 101, 116
]

private static var secretKey: String {
    return String(bytes: encryptedSecretKey, encoding: .utf8) ?? ""
}
```

### 3. 反调试检查
```swift
private static func isDebugging() -> Bool {
    var info = kinfo_proc()
    var mib = [CTL_KERN, KERN_PROC, KERN_PROC_PID, getpid()]
    var size = MemoryLayout<kinfo_proc>.stride
    
    let result = sysctl(&mib, UInt32(mib.count), &info, &size, nil, 0)
    return result == 0 && (info.kp_proc.p_flag & P_TRACED) != 0
}
```

## 🔥 优势

### 对比网络验证

| 特性 | 网络验证 | 本地验证 |
|------|----------|----------|
| **离线使用** | ❌ | ✅ |
| **服务器依赖** | ✅ 需要 | ❌ 不需要 |
| **实现复杂度** | 高 | 低 |
| **用户体验** | 需要网络 | 即时验证 |
| **安全性** | 很高 | 中等 |

### 破解难度

- **普通用户**：完全无法破解 ✅
- **中级用户**：需要逆向分析算法 ⚠️
- **专业破解**：仍可能破解 ❌

## 🎯 要我实现吗？

这个方案的优点：

1. **无需服务器**：纯本地验证
2. **用户体验好**：离线即可验证
3. **实现简单**：不需要网络请求处理
4. **足够安全**：对大多数用户有效

你觉得这个简化方案如何？要我继续实现完整的本地验证系统吗？

---

**关于你提到的 bsphp.com**：这个方案也支持，我们可以在那里部署 PHP 卡密生成脚本！
